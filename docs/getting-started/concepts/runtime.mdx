---
sidebar_position: 1
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Conductor Server Runtime

## Definitions (aka Metadata or Blueprints)
Conductor definitions are like class definitions in OOP paradigm, or templates. 
You define this once, and use for each workflow execution. Definitions to Executions have 1:N relationship.

Conductor does not enforce one specific way to define your workflows.  You can create your workflow definitions in multiple ways:
1. Using Code with SDK support in Java, Golang, Python, C#, Javascript and Clojure.
2. Using JSON based configuration
3. Visually using UI

Whichever way you create your workflows, they are all interoperable.

## Workflow
Conductor workflows are a composition of Tasks and Operators and defines the control flow of your application.
Workflows are defined using configuration or Code.

#### Workflow = {Tasks + Operators}
[Detailed description](/configuration/workflowdef.html)

## Example workflow

#### Code

<Tabs>
  <TabItem value="Diagram" label="Diagram" default>
    <p align="left"><img src="/content/img/sample_workflow.jpg" alt="Diagram of a sample workflow" width="200" style={{paddingBottom: 10, paddingTop: 10}} /></p>
  </TabItem>
  <TabItem value="JSON" label="JSON">

```json title="JSON Code"
{
  "name": "example_workflow",
  "version": 1,
  "tasks": [
    {
      "name": "switch_case",
      "taskReferenceName": "switch_case",
      "inputParameters": {
        "switchCaseValue": "${workflow.input.service}"
      },
      "type": "SWITCH",
      "decisionCases": {
        "AZURE": [
          {
            "name": "deploy_to_azure",
            "taskReferenceName": "deploy_to_azure",
            "inputParameters": {},
            "type": "SIMPLE"
          }
        ]
      },
      "defaultCase": [
        {
          "name": "deploy_to_aws_1",
          "taskReferenceName": "deploy_to_aws",
          "inputParameters": {},
          "type": "SIMPLE"
        }
      ],
      "evaluatorType": "value-param",
      "expression": "switchCaseValue"
    }
  ]
}
```

  </TabItem>
  <TabItem value="Java" label="Java">

```java title="Java Code for the workflow"
ConductorWorkflow workflow = new ConductorWorkflow(workflowExecutor);
Switch decision = new Switch("switch_case", "${workflow.input.service}");
decision.switchCase("AZURE", new SimpleTask("deploy_to_azure", "deploy_to_azure"));
decision.defaultCase(new SimpleTask("deploy_to_aws_1", "deploy_to_aws_"));
workflow.add(decision);
```

  </TabItem>
  <TabItem value="Golang" label="Golang">
    This is a banana üçå
  </TabItem>
  <TabItem value="Python" label="Python">
      This is a banana üçå
  </TabItem>
  <TabItem value="CSharp" label="CSharp">
      This is a banana üçå
  </TabItem>
</Tabs>

## Tasks
Tasks are what implements the business logic in the workflow.  They are re-usable, follows single responsibility principle and can be used across multiple workflows.

A task can be:

1. A microservice exposed via HTTP or gRPC
2. A serverless component such as Lambda function or a container
3. A Conductor worker designed to handle a specific business task such as processing data from a file or database.

:::caution
Conductor provides `at-least once` delivery guarantees for the messages in the system.

The task implementation should be either idempotent or designed to fail if executed more than once.

:::

### Task Definition
Task definitions help define Task level parameters like inputs and outputs, timeouts, retries etc.

* All tasks need to be registered before they can be used by active workflows.
* A task can be re-used within multiple workflows.

[Detailed description](/configuration/taskdef.html)

## System Tasks
System tasks are executed within the JVM of the Conductor server and managed by Conductor for its execution and scalability.

See [Systems tasks](/configuration/systask.html) for list of available Task types, and instructions for using them.

!!! Note
Conductor provides an API to create user defined tasks that are executed in the same JVM as the engine.	See [WorkflowSystemTask](https://github.com/Netflix/conductor/blob/main/core/src/main/java/com/netflix/conductor/core/execution/tasks/WorkflowSystemTask.java) interface for details.

## Worker Tasks
Worker tasks are implemented by your application(s) and run in a separate environment from Conductor. The worker tasks can be implemented in any language.  These tasks talk to Conductor server via REST/gRPC to poll for tasks and update its status after execution.

Worker tasks are identified by task type __SIMPLE__ in the blueprint.

# Core Concepts
Conductor is a platform for building distributed application using Orchestration.

## Workflow = {Tasks + Operators}

Conductor workflows are a composition of Tasks and Operators.  An operator in a workflow is your programming language construct such as switch, loop, fork/join or a return statement. A task represents business logic execution such as making an HTTP call, sending email, or doing some custom work such as processing data files or executing some business logic.

Tasks are executed by Workers that run outside of the Conductor server deployment.  Conductor is agnostic to how the workers are deployed and run and provides lightweight SDKs in all major languages that allows you to expose existing functionality as Conductor Workers.

Workers can run on bare metal, on containers, VMs, or as serverless functions.  

Conductor also provides pre-built workers for most commonly used tasks called [system tasks](/content/docs/getting-started/concepts/system-tasks).


